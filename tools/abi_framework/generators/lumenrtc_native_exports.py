#!/usr/bin/env python3
from __future__ import annotations

import argparse
import difflib
import json
from pathlib import Path
from typing import Any


def load_idl(path: Path) -> dict[str, Any]:
    data = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(data, dict):
        raise SystemExit(f"IDL '{path}' must be a JSON object")
    return data


def normalize_type(value: str) -> str:
    return " ".join(value.replace("\t", " ").split())


def render_params(parameters: list[dict[str, Any]]) -> str:
    if not parameters:
        return "void"
    parts: list[str] = []
    for idx, param in enumerate(parameters):
        name = str(param.get("name") or f"arg{idx}")
        c_type = normalize_type(str(param.get("c_type") or "void"))
        if c_type == "...":
            parts.append("...")
            continue
        parts.append(f"{c_type} {name}")
    return ", ".join(parts)


def render_arg_list(parameters: list[dict[str, Any]]) -> str:
    if not parameters:
        return ""
    names: list[str] = []
    for idx, param in enumerate(parameters):
        c_type = str(param.get("c_type") or "void")
        if c_type == "...":
            continue
        name = str(param.get("name") or f"arg{idx}")
        names.append(name)
    return ", ".join(names)


def render_impl_header(functions: list[dict[str, Any]]) -> str:
    lines: list[str] = []
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include \"lumenrtc.h\"")
    lines.append("")
    lines.append("#ifdef __cplusplus")
    lines.append("extern \"C\" {")
    lines.append("#endif")
    lines.append("")
    for func in functions:
        name = str(func.get("name") or "")
        if not name:
            continue
        return_type = normalize_type(str(func.get("c_return_type") or "void"))
        params = func.get("parameters")
        if not isinstance(params, list):
            params = []
        signature = render_params(params)
        impl_name = "lrtc_impl_" + name[len("lrtc_"):] if name.startswith("lrtc_") else "lrtc_impl_" + name
        lines.append(f"{return_type} LUMENRTC_CALL {impl_name}({signature});")
    lines.append("")
    lines.append("#ifdef __cplusplus")
    lines.append("}")
    lines.append("#endif")
    lines.append("")
    return "\n".join(lines)


def render_exports(functions: list[dict[str, Any]]) -> str:
    lines: list[str] = []
    lines.append("// <auto-generated />")
    lines.append("// Generated by tools/abi_framework/generators/lumenrtc_native_exports.py")
    lines.append("#include \"lumenrtc.h\"")
    lines.append("#include \"lumenrtc_impl.h\"")
    lines.append("")
    lines.append("#ifdef __cplusplus")
    lines.append("extern \"C\" {")
    lines.append("#endif")
    lines.append("")
    for func in functions:
        name = str(func.get("name") or "")
        if not name:
            continue
        return_type = normalize_type(str(func.get("c_return_type") or "void"))
        params = func.get("parameters")
        if not isinstance(params, list):
            params = []
        signature = render_params(params)
        args = render_arg_list(params)
        impl_name = "lrtc_impl_" + name[len("lrtc_"):] if name.startswith("lrtc_") else "lrtc_impl_" + name
        lines.append(f"LUMENRTC_API {return_type} LUMENRTC_CALL {name}({signature}) {{")
        if return_type == "void":
            if args:
                lines.append(f"    {impl_name}({args});")
            else:
                lines.append(f"    {impl_name}();")
            lines.append("}")
        else:
            if args:
                lines.append(f"    return {impl_name}({args});")
            else:
                lines.append(f"    return {impl_name}();")
            lines.append("}")
        lines.append("")
    lines.append("#ifdef __cplusplus")
    lines.append("}")
    lines.append("#endif")
    lines.append("")
    return "\n".join(lines)


def write_if_changed(path: Path, content: str, check: bool, dry_run: bool) -> int:
    existing = path.read_text(encoding="utf-8") if path.exists() else ""
    if existing == content:
        return 0
    if check:
        diff = difflib.unified_diff(
            existing.splitlines(),
            content.splitlines(),
            fromfile=f"a/{path}",
            tofile=f"b/{path}",
            lineterm="",
        )
        print("\n".join(diff))
        return 1
    if not dry_run:
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding="utf-8")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--idl", required=True)
    parser.add_argument("--out", required=True)
    parser.add_argument("--impl-header", required=True)
    parser.add_argument("--check", action="store_true")
    parser.add_argument("--dry-run", action="store_true")
    args = parser.parse_args()

    idl_path = Path(args.idl)
    out_path = Path(args.out)
    header_path = Path(args.impl_header)

    idl = load_idl(idl_path)
    functions = idl.get("functions")
    if not isinstance(functions, list):
        raise SystemExit("IDL missing 'functions' array")

    exports = render_exports(functions)
    header = render_impl_header(functions)

    status = 0
    status |= write_if_changed(out_path, exports, args.check, args.dry_run)
    status |= write_if_changed(header_path, header, args.check, args.dry_run)
    return status


if __name__ == "__main__":
    raise SystemExit(main())

#!/usr/bin/env python3
from __future__ import annotations

import argparse
import difflib
import json
from pathlib import Path
from typing import Any


def load_json(path: Path) -> dict[str, Any]:
    data = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(data, dict):
        raise SystemExit(f"'{path}' must be a JSON object")
    return data


def write_if_changed(path: Path, content: str, check: bool, dry_run: bool) -> int:
    existing = path.read_text(encoding="utf-8") if path.exists() else ""
    if existing == content:
        return 0
    if check:
        diff = difflib.unified_diff(
            existing.splitlines(),
            content.splitlines(),
            fromfile=f"a/{path}",
            tofile=f"b/{path}",
            lineterm="",
        )
        print("\n".join(diff))
        return 1
    if not dry_run:
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding="utf-8")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--idl", required=True)
    parser.add_argument("--managed", required=True)
    parser.add_argument("--out", required=True)
    parser.add_argument("--check", action="store_true")
    parser.add_argument("--dry-run", action="store_true")
    args = parser.parse_args()

    idl = load_json(Path(args.idl))
    functions = {f.get("name"): f for f in idl.get("functions", []) if isinstance(f, dict)}

    managed = load_json(Path(args.managed))
    handles = managed.get("handles")
    if not isinstance(handles, list):
        raise SystemExit("managed metadata must contain 'handles' array")

    lines: list[str] = []
    lines.append("// <auto-generated />")
    lines.append("// Generated by tools/abi_framework/generators/lumenrtc_csharp_handles.py")
    lines.append("using System;")
    lines.append("using System.Runtime.InteropServices;")
    lines.append("")

    current_ns = None
    for entry in handles:
        if not isinstance(entry, dict):
            continue
        ns = entry.get("namespace")
        cs_type = entry.get("cs_type")
        release = entry.get("release")
        access = entry.get("access") or "public"
        if not (isinstance(ns, str) and isinstance(cs_type, str) and isinstance(release, str)):
            continue
        if release not in functions:
            raise SystemExit(f"Release function '{release}' not found in IDL")

        if current_ns != ns:
            if current_ns is not None:
                lines.append("")
            lines.append(f"namespace {ns};")
            lines.append("")
            current_ns = ns

        lines.append(f"{access} sealed partial class {cs_type}")
        lines.append("{")
        lines.append("    public override bool IsInvalid => handle == IntPtr.Zero;")
        lines.append("")
        lines.append("    protected override bool ReleaseHandle()")
        lines.append("    {")
        lines.append(f"        LumenRTC.Interop.NativeMethods.{release}(handle);")
        lines.append("        return true;")
        lines.append("    }")
        lines.append("}")
        lines.append("")

    content = "\n".join(lines)
    if not content.endswith("\n"):
        content += "\n"

    return write_if_changed(Path(args.out), content, args.check, args.dry_run)


if __name__ == "__main__":
    raise SystemExit(main())

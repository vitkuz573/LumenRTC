using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace LumenRTC.Abi.RoslynGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class LumenRtcAbiInteropGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor MissingIdlDescriptor = new(
        id: "LRTCABI001",
        title: "ABI IDL file not found",
        messageFormat: "ABI IDL file '{0}' was not found in AdditionalFiles; configure AdditionalFiles and LumenRtcAbiIdlPath",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor MultipleIdlDescriptor = new(
        id: "LRTCABI002",
        title: "Multiple ABI IDL files matched",
        messageFormat: "Multiple AdditionalFiles match ABI IDL path '{0}': {1}; keep exactly one match",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor EmptyIdlDescriptor = new(
        id: "LRTCABI003",
        title: "ABI IDL file is empty",
        messageFormat: "ABI IDL file '{0}' is empty or unreadable",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor GenerationFailedDescriptor = new(
        id: "LRTCABI004",
        title: "ABI source generation failed",
        messageFormat: "Failed to generate interop from '{0}' because {1}",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor MissingManagedMetadataDescriptor = new(
        id: "LRTCABI005",
        title: "Managed metadata file not found",
        messageFormat: "Managed metadata file '{0}' was not found in AdditionalFiles; configure AdditionalFiles and LumenRtcAbiManagedMetadataPath",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor MultipleManagedMetadataDescriptor = new(
        id: "LRTCABI006",
        title: "Multiple managed metadata files matched",
        messageFormat: "Multiple AdditionalFiles match managed metadata path '{0}': {1}; keep exactly one match",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor EmptyManagedMetadataDescriptor = new(
        id: "LRTCABI007",
        title: "Managed metadata file is empty",
        messageFormat: "Managed metadata file '{0}' is empty or unreadable",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor MissingManagedHandleTypeDescriptor = new(
        id: "LRTCABI008",
        title: "Managed handle base type not found",
        messageFormat: "Managed handle '{0}' was not found in compilation; declare a partial SafeHandle class with this full name",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor InvalidManagedHandleTypeDescriptor = new(
        id: "LRTCABI009",
        title: "Managed handle base type must be partial class",
        messageFormat: "Managed handle '{0}' must be declared as a partial class in project source",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor ManagedHandleBaseTypeDescriptor = new(
        id: "LRTCABI010",
        title: "Managed handle base type must inherit SafeHandle",
        messageFormat: "Managed handle '{0}' must derive from System.Runtime.InteropServices.SafeHandle",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor ManagedHandleAccessMismatchDescriptor = new(
        id: "LRTCABI011",
        title: "Managed handle accessibility mismatch",
        messageFormat: "Managed handle '{0}' metadata access '{1}' does not match declared accessibility '{2}'",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor DuplicateManagedHandleDescriptor = new(
        id: "LRTCABI012",
        title: "Duplicate managed handle metadata entry",
        messageFormat: "Managed metadata contains duplicate handle entry '{0}'",
        category: "LumenRTC.Abi.SourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var optionsProvider = context.AnalyzerConfigOptionsProvider
            .Select(static (provider, _) => GeneratorOptions.From(provider.GlobalOptions));

        var additionalFilesProvider = context.AdditionalTextsProvider
            .Select(static (file, cancellationToken) => new AdditionalFileSnapshot(
                file.Path,
                file.GetText(cancellationToken)?.ToString()
            ))
            .Collect();

        var generationInputProvider = context.CompilationProvider.Combine(additionalFilesProvider.Combine(optionsProvider));
        context.RegisterSourceOutput(generationInputProvider, static (spc, input) =>
        {
            Execute(spc, input.Left, input.Right.Left, input.Right.Right);
        });
    }

    private static void Execute(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<AdditionalFileSnapshot> files,
        GeneratorOptions options)
    {
        var matchedIdlFile = ResolveSingleAdditionalFile(
            context,
            files,
            options.IdlPath,
            options.MatchesIdlPath,
            MissingIdlDescriptor,
            MultipleIdlDescriptor,
            EmptyIdlDescriptor);
        if (!matchedIdlFile.HasValue)
        {
            return;
        }

        var matchedManagedFile = ResolveSingleAdditionalFile(
            context,
            files,
            options.ManagedMetadataPath,
            options.MatchesManagedMetadataPath,
            MissingManagedMetadataDescriptor,
            MultipleManagedMetadataDescriptor,
            EmptyManagedMetadataDescriptor);
        if (!matchedManagedFile.HasValue)
        {
            return;
        }

        try
        {
            var model = AbiInteropSourceEmitter.ParseIdl(matchedIdlFile.Value.Content!);
            var source = AbiInteropSourceEmitter.RenderCode(model, options);
            context.AddSource(
                BuildHintName(options.ClassName, "Abi"),
                SourceText.From(source, Encoding.UTF8)
            );

            var typeModel = AbiInteropTypesSourceEmitter.ParseIdl(matchedIdlFile.Value.Content!);
            var typesSource = AbiInteropTypesSourceEmitter.RenderTypesCode(typeModel, options);
            context.AddSource(
                BuildHintName(options.ClassName, "Types"),
                SourceText.From(typesSource, Encoding.UTF8)
            );

            var managedHandlesModel = AbiInteropTypesSourceEmitter.ParseManagedMetadata(matchedManagedFile.Value.Content!);
            if (!ValidateManagedHandleTypes(context, compilation, managedHandlesModel))
            {
                return;
            }

            var handlesSource = AbiInteropTypesSourceEmitter.RenderHandlesCode(typeModel, managedHandlesModel, options);
            context.AddSource(
                BuildHintName(options.ClassName, "Handles"),
                SourceText.From(handlesSource, Encoding.UTF8)
            );
        }
        catch (GeneratorException ex)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(GenerationFailedDescriptor, Location.None, matchedIdlFile.Value.Path, ex.Message)
            );
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(GenerationFailedDescriptor, Location.None, matchedIdlFile.Value.Path, ex.Message)
            );
        }
    }

    private static AdditionalFileSnapshot? ResolveSingleAdditionalFile(
        SourceProductionContext context,
        ImmutableArray<AdditionalFileSnapshot> files,
        string configuredPath,
        Func<string, bool> matcher,
        DiagnosticDescriptor missingDescriptor,
        DiagnosticDescriptor multipleDescriptor,
        DiagnosticDescriptor emptyDescriptor)
    {
        var matches = files
            .Where(file => matcher(file.Path))
            .OrderBy(file => file.Path, StringComparer.Ordinal)
            .ToArray();

        if (matches.Length == 0)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(missingDescriptor, Location.None, configuredPath)
            );
            return null;
        }

        if (matches.Length > 1)
        {
            var preview = string.Join(", ", matches.Take(3).Select(item => item.Path));
            if (matches.Length > 3)
            {
                preview += ", ...";
            }

            context.ReportDiagnostic(
                Diagnostic.Create(multipleDescriptor, Location.None, configuredPath, preview)
            );
            return null;
        }

        var match = matches[0];
        if (string.IsNullOrWhiteSpace(match.Content))
        {
            context.ReportDiagnostic(
                Diagnostic.Create(emptyDescriptor, Location.None, match.Path)
            );
            return null;
        }

        return match;
    }

    private static bool ValidateManagedHandleTypes(
        SourceProductionContext context,
        Compilation compilation,
        ManagedHandlesModel handlesModel)
    {
        var safeHandleType = compilation.GetTypeByMetadataName("System.Runtime.InteropServices.SafeHandle");
        if (safeHandleType is null)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    GenerationFailedDescriptor,
                    Location.None,
                    "<compilation>",
                    "type System.Runtime.InteropServices.SafeHandle is unavailable"
                )
            );
            return false;
        }

        var seenHandles = new HashSet<string>(StringComparer.Ordinal);
        var success = true;

        foreach (var handle in handlesModel.Handles)
        {
            var fullTypeName = BuildManagedTypeFullName(handle.NamespaceName, handle.CsType);
            if (!seenHandles.Add(fullTypeName))
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(DuplicateManagedHandleDescriptor, Location.None, fullTypeName)
                );
                success = false;
                continue;
            }

            var handleType = compilation.GetTypeByMetadataName(fullTypeName);
            if (handleType is null)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(MissingManagedHandleTypeDescriptor, Location.None, fullTypeName)
                );
                success = false;
                continue;
            }

            if (!IsPartialClass(handleType, context.CancellationToken))
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(InvalidManagedHandleTypeDescriptor, Location.None, fullTypeName)
                );
                success = false;
            }

            if (!InheritsFrom(handleType, safeHandleType))
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(ManagedHandleBaseTypeDescriptor, Location.None, fullTypeName)
                );
                success = false;
            }

            var expectedAccessibility = string.Equals(handle.Access, "public", StringComparison.Ordinal)
                ? Accessibility.Public
                : Accessibility.Internal;
            if (handleType.DeclaredAccessibility != expectedAccessibility)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        ManagedHandleAccessMismatchDescriptor,
                        Location.None,
                        fullTypeName,
                        HandleAccessText(expectedAccessibility),
                        HandleAccessText(handleType.DeclaredAccessibility)
                    )
                );
                success = false;
            }
        }

        return success;
    }

    private static bool IsPartialClass(INamedTypeSymbol symbol, System.Threading.CancellationToken cancellationToken)
    {
        if (symbol.TypeKind != TypeKind.Class || symbol.DeclaringSyntaxReferences.Length == 0)
        {
            return false;
        }

        foreach (var reference in symbol.DeclaringSyntaxReferences)
        {
            if (reference.GetSyntax(cancellationToken) is not ClassDeclarationSyntax declaration)
            {
                return false;
            }

            if (!declaration.Modifiers.Any(static token => token.IsKind(SyntaxKind.PartialKeyword)))
            {
                return false;
            }
        }

        return true;
    }

    private static bool InheritsFrom(INamedTypeSymbol symbol, INamedTypeSymbol baseType)
    {
        for (INamedTypeSymbol? current = symbol; current != null; current = current.BaseType)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
            {
                return true;
            }
        }

        return false;
    }

    private static string BuildManagedTypeFullName(string namespaceName, string typeName)
    {
        return string.IsNullOrWhiteSpace(namespaceName)
            ? typeName
            : namespaceName + "." + typeName;
    }

    private static string HandleAccessText(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => accessibility.ToString().ToLowerInvariant(),
        };
    }

    private static string BuildHintName(string className, string suffix)
    {
        var effectiveClassName = string.IsNullOrWhiteSpace(className)
            ? "NativeMethods"
            : className.Trim();
        var sanitized = Regex.Replace(effectiveClassName, "[^A-Za-z0-9_]+", "_");
        if (string.IsNullOrWhiteSpace(sanitized))
        {
            sanitized = "NativeMethods";
        }

        return sanitized + "." + suffix + ".g.cs";
    }

    private readonly struct AdditionalFileSnapshot
    {
        public AdditionalFileSnapshot(string path, string? content)
        {
            Path = path;
            Content = content;
        }

        public string Path { get; }

        public string? Content { get; }
    }
}
